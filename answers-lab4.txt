Question 

1.Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S? 
Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.

Answer:
MPBOOTPHYS的作用是计算传入参数的绝对地址，即物理地址，这样做的原因是kern/mpentry.S处于实模式中。

2.It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.

Answer:
如果所有CPU共享内核栈，那么当多个CPU出现中断时，这些CPU就会试图在一个栈上进行push/pop操作，即使有锁保护也有可能出现数据竞争从而导致错误的结果。

3.In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context--the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch?

Answer:
因为所有的用户进程中kernel space的地址都相同，不同的只有user space的虚拟地址。